# Simple Docker


## Оглавление

[Часть 1. Готовый докер](#часть-1-готовый-докер)  
[Часть 2. Операции с контейнером](#часть-2-операции-с-контейнером)  
[Часть 3. Мини веб-сервер](#часть-3-мини-веб-сервер)  
[Часть 4. Свой докер](#часть-4-свой-докер)  
[Часть 5. Dockle](#часть-5-dockle)  
[Часть 6. Базовый Docker Compose](#часть-6-базовый-docker-compose)  


## Часть 1. Готовый докер

- Скачиваю [официальный](https://hub.docker.com/_/nginx) ngnix образ `docker pull nginx`

![docker pull nginx](01/1.png)

- Проверяю наличие образа `docker images`

![docker images](01/2.png)

- Запускаю образ `docker run -d nginx`

> -d - запуск контейнера в фоновом режиме

![docker run -d nginx](01/3.png)

- Проверяю, что образ запущен `docker ps`

![docker ps](01/4.png)

- Информация о контейнере `docker inspect -s`

> -s --size, добавляет в окно настройки два дополнительных поля

- Размер контейнера

![Размер контейнера](01/5.png)

> SizeRootFs: общий размер всех файлов в контейнере в байтах

> SizeRw: размер файлов, созданных или измененных в контейнере, по сравнению с его образом, в байтах

- Список портов

![Список портов](01/6.png)

- ip контейнера

![ip контейнера](01/7.png)

- Останавливаю контейнер `docker stop`

![docker stop](01/8.png)

- Проверяю, что образ остановлен `docker ps`

![docker ps](01/9.png)

- Запускаю контейнер с замапленными портами 80 и 443

`docker run -d -p 80:80 -p 443:443 nginx`

> -p: используется для публикации портов из контейнера на хост

> -p 80:80сопоставляет порт 80 на хосте с портом 80 в контейнере и также для порта 443

![docker run](01/10.png)

> "Замапить порт" - переадресация принимаемых данных таким образом, чтобы данные, принимаемые на какой-то порт одного компьютера автоматически переадресовывались на какой-то другой порт другого компьютера

- Проверяю стартовую страницу в бразузере

![localhoost](01/11.png)

- Перезапускаю контейнер `docker restart`

![docker restart](01/12.png)

- Проверяю, что образ перезапущен `docker ps`

![docker ps](01/13.png)



## Часть 2. Операции с контейнером

- Читаю конфигурационный файл

> docker exec используется для выполнения команды в работающем контейнере

![nginx.conf](02/1.png)

- Создаю на локальной машине конфигурационный файл `touch nginx.conf`

![new nginx.conf](02/2.png)

- Копирую файл в nginx `docker cp`

![docker cp](02/3.png)

- Перезапускаю nginx `nginx -s reload`

![nginx -s reload](02/4.png)

- Проверяю, что все работает 

![localhost/status](02/5.png)

- Экспортирую контейнер `docker export`

- Останавливаю контейнер `docker stop`

![docker stop](02/6.png)

- Удаляю образ `docker rmi`

![docker rmi](02/7.png)

> Флаг -f — это принудительный флаг, который приводит к удалению образа Docker без подтверждения. Он используется, чтобы избежать интерактивного запроса на подтверждение удаления.

- Удаляю контейнер `docker rm`

![docker rm](02/8.png)

- Импортирую образ `docker import`

![docker import](02/9.png)

- Запускаю контейнер `docker run`

![docker run](02/10.png)

- Проверяю, что все работает 

![localhost/status](02/11.png)


## Часть 3. Мини веб-сервер

- Чтобы создать свой мини веб-сервер, необходимо создать `.c` файл, в котором будет описана логика сервера (в нашем случае - вывод сообщения Hello World!), а также конфиг `nginx.conf`, который будет проксировать все запросы с порта `81` на порт `127.0.0.1:8080`

`server.c`

![server.c](03/1.1.png)

`nginx.conf`

![nginx.conf](03/1.2.png)

- Заново выкачиваю [официальный](https://hub.docker.com/_/nginx) ngnix образ `docker pull nginx`

![docker pull nginx](03/1.png)

- Запускаю контейнер `docker run`

![docker run](03/2.png)

> --name: имя контейнера

- Копирую файл сервера и конфигурационный файл в контейнер `docker cp`

![docker cp](03/3.png)

- Устанавливаю необходимые пакеты в контейнер

![apt-get install](03/4.png)

- Компилирую и запускаю сервер

![gcc](03/5.png)

- Перезапускаю nginx `nginx -s reload`

![reload](03/6.png)

- Проверяю, что все работает запускаю в браузере `localhost:81`

![curl localhost:81](03/7.png)


## Часть 4. Свой докер

- Напишем свой docker-образ, который собирает исходники 3-й части, запускает на порту 80, после копирует внутрь написанный нами `nginx.conf` и, наконец, запускает nginx (ниже приведены файлы `script.sh` и `Dockerfile`, файлы `nginx.conf` и `server.c` остаются с 3-й части)

`script.sh`

![script](04/1.png)

`Dockerfile`

![nginx.conf](04/2.png)

- Собираю образ `docker build` и проверяю его наличие `docker images`

![docker build](04/3.png)

> -t: Имя и при необходимости, тег в формате name:tag

- Теперь удостоверимся, что все собралось, проверив наличие соответствующего образа командой `docker images`

![docker images](04/4.png)

- Запускаю контейнер `docker run` и проверяю, что все работает `docker ps`

- Смотрю `curl localhost`

![docker run](04/5.png)

> -v: Привязка монтирования тома

> -i: Держит STDIN открытым, даже если он не подключен

> -t: Выделение псевдо-TTY

> -p: Публикация портов контейнера на хосте

- Теперь добавим в файл `nginx.conf` проксирование странички `/status`, по которой необходимо отдавать статус сервера `nginx`

![nginx.conf](04/6.png)

- Обновляю конфиг на локальной машине, перезапускаю nginx `nginx -s reload`

![nginx -s reload](04/7.png)

- Проверяю `localhost/status`

![curl localhost/status](04/8.png)


## Часть 5. Dockle

- Проверяю образ `school_21_1`

![Dockle](05/1.png)

- После правки всех `FATATL` и `WARN`

![Dockle](05/2.png)


## Часть 6. Базовый Docker Compose

- Для начала остановим все запущенные контейнеры командой `docker stop`

- Затем изменим конфигурационные файлы

- Собираю образы `docker compose build`

![compose build](06/1.png)

- Запускаю контейнеры и проверяю, что все работает `docker compose up -d`, `curl localhost:80`, `curl localhost/status`

![compose build](06/2.png)

> -d: deamon

[Оглавление](#Оглавление)